/*!
 * The MIT License (MIT)
 *
 * Copyright (c) 2020 Peculiar Ventures, LLC
 * 
 * See the full version of the license https://github.com/PeculiarVentures/node-webcrypto-p11/blob/master/LICENSE
 */

import { __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import * as core from 'webcrypto-core';
import * as graphene from 'graphene-pk11';
import * as pkcs11 from 'pkcs11js';
import * as pvtsutils from 'pvtsutils';
import * as x509 from '@peculiar/x509';
import * as asn1Schema from '@peculiar/asn1-schema';
import * as asnX509 from '@peculiar/asn1-x509';
import * as crypto from 'crypto';
import * as jsonSchema from '@peculiar/json-schema';

class CryptoKey extends core.CryptoKey {
    static defaultKeyAlgorithm() {
        const alg = {
            label: "",
            name: "",
            sensitive: false,
            token: false,
        };
        return alg;
    }
    static getID(p11Key) {
        let name;
        switch (p11Key.class) {
            case graphene.ObjectClass.PRIVATE_KEY:
                name = "private";
                break;
            case graphene.ObjectClass.PUBLIC_KEY:
                name = "public";
                break;
            case graphene.ObjectClass.SECRET_KEY:
                name = "secret";
                break;
            default:
                throw new Error(`Unsupported Object type '${graphene.ObjectClass[p11Key.class]}'`);
        }
        return `${name}-${p11Key.handle.toString("hex")}-${p11Key.id.toString("hex")}`;
    }
    get key() {
        return this.p11Object.toType();
    }
    constructor(key, alg, usages) {
        super();
        this.type = "secret";
        this.extractable = false;
        this.usages = [];
        this.p11Object = key;
        switch (key.class) {
            case graphene.ObjectClass.PUBLIC_KEY:
                this.initPublicKey(key.toType());
                break;
            case graphene.ObjectClass.PRIVATE_KEY:
                this.initPrivateKey(key.toType());
                break;
            case graphene.ObjectClass.SECRET_KEY:
                this.initSecretKey(key.toType());
                break;
            default:
                throw new core.CryptoError(`Wrong incoming session object '${graphene.ObjectClass[key.class]}'`);
        }
        const { name, ...defaultAlg } = CryptoKey.defaultKeyAlgorithm();
        this.algorithm = { ...alg, ...defaultAlg };
        this.id = CryptoKey.getID(key);
        if (usages) {
            this.usages = usages;
        }
        try {
            this.algorithm.label = key.label;
        }
        catch { }
        try {
            this.algorithm.token = key.token;
        }
        catch { }
        try {
            if (key instanceof graphene.PrivateKey || key instanceof graphene.SecretKey) {
                this.algorithm.sensitive = key.get("sensitive");
            }
        }
        catch { }
        this.onAssign();
    }
    toJSON() {
        return {
            algorithm: this.algorithm,
            type: this.type,
            usages: this.usages,
            extractable: this.extractable,
        };
    }
    initPrivateKey(key) {
        this.p11Object = key;
        this.type = "private";
        this.alwaysAuthenticate = key.alwaysAuthenticate;
        try {
            this.extractable = key.extractable;
        }
        catch {
            this.extractable = false;
        }
        this.usages = [];
        if (key.decrypt) {
            this.usages.push("decrypt");
        }
        if (key.derive) {
            this.usages.push("deriveKey");
            this.usages.push("deriveBits");
        }
        if (key.sign) {
            this.usages.push("sign");
        }
        if (key.unwrap) {
            this.usages.push("unwrapKey");
        }
    }
    initPublicKey(key) {
        this.p11Object = key;
        this.type = "public";
        this.extractable = true;
        if (key.encrypt) {
            this.usages.push("encrypt");
        }
        if (key.verify) {
            this.usages.push("verify");
        }
        if (key.wrap) {
            this.usages.push("wrapKey");
        }
    }
    initSecretKey(key) {
        this.p11Object = key;
        this.type = "secret";
        try {
            this.extractable = key.extractable;
        }
        catch {
            this.extractable = false;
        }
        if (key.sign) {
            this.usages.push("sign");
        }
        if (key.verify) {
            this.usages.push("verify");
        }
        if (key.encrypt) {
            this.usages.push("encrypt");
        }
        if (key.decrypt) {
            this.usages.push("decrypt");
        }
        if (key.wrap) {
            this.usages.push("wrapKey");
        }
        if (key.unwrap) {
            this.usages.push("unwrapKey");
        }
        if (key.derive) {
            this.usages.push("deriveKey");
            this.usages.push("deriveBits");
        }
    }
    onAssign() {
    }
}

class Assert {
    static isSession(data) {
        if (!(data instanceof graphene.Session)) {
            throw new TypeError("PKCS#11 session is not initialized");
        }
    }
    static isModule(data) {
        if (!(data instanceof graphene.Module)) {
            throw new TypeError("PKCS#11 module is not initialized");
        }
    }
    static isCryptoKey(data) {
        if (!(data instanceof CryptoKey)) {
            throw new TypeError("Object is not an instance of PKCS#11 CryptoKey");
        }
    }
    static requiredParameter(parameter, parameterName) {
        if (!parameter) {
            throw new Error(`Absent mandatory parameter "${parameterName}"`);
        }
    }
}

class Pkcs11Object {
    static assertStorage(obj) {
        if (!obj) {
            throw new TypeError("PKCS#11 object is empty");
        }
    }
    constructor(object) {
        this.p11Object = object;
    }
}

class CryptoCertificate extends Pkcs11Object {
    static getID(p11Object) {
        let type;
        let id;
        if (p11Object instanceof graphene.Data) {
            type = "request";
            id = p11Object.objectId;
        }
        else if (p11Object instanceof graphene.X509Certificate) {
            type = "x509";
            id = p11Object.id;
        }
        if (!type || !id) {
            throw new Error("Unsupported PKCS#11 object");
        }
        return `${type}-${p11Object.handle.toString("hex")}-${id.toString("hex")}`;
    }
    get id() {
        Pkcs11Object.assertStorage(this.p11Object);
        return CryptoCertificate.getID(this.p11Object);
    }
    get token() {
        try {
            Pkcs11Object.assertStorage(this.p11Object);
            return this.p11Object.token;
        }
        catch { }
        return false;
    }
    get sensitive() {
        return false;
    }
    get label() {
        try {
            Pkcs11Object.assertStorage(this.p11Object);
            return this.p11Object.label;
        }
        catch { }
        return "";
    }
    constructor(crypto) {
        super();
        this.type = "x509";
        this.crypto = crypto;
    }
    async computeID() {
        let id = this.publicKey.p11Object.id;
        const indexes = await this.crypto.keyStorage.keys();
        if (!indexes.some(o => o.split("-")[2] === id.toString("hex"))) {
            let certKeyRaw;
            try {
                certKeyRaw = await this.crypto.subtle.exportKey("spki", this.publicKey);
            }
            catch {
                return id;
            }
            for (const index of indexes) {
                const [type] = index.split("-");
                if (type !== "public") {
                    continue;
                }
                let keyRaw;
                try {
                    const key = await this.crypto.keyStorage.getItem(index);
                    keyRaw = await this.crypto.subtle.exportKey("spki", key);
                    if (pvtsutils.BufferSourceConverter.isEqual(keyRaw, certKeyRaw)) {
                        id = key.p11Object.id;
                        break;
                    }
                }
                catch {
                    continue;
                }
            }
        }
        return id;
    }
}

class ParserError extends Error {
    constructor(message) {
        super(message);
        this.name = "ParserError";
    }
}

class X509CertificateRequest extends CryptoCertificate {
    constructor() {
        super(...arguments);
        this.type = "request";
    }
    get subjectName() {
        var _a;
        return (_a = this.getData()) === null || _a === undefined ? undefined : _a.subject;
    }
    get value() {
        Pkcs11Object.assertStorage(this.p11Object);
        return new Uint8Array(this.p11Object.value).buffer;
    }
    async importCert(data, algorithm, keyUsages) {
        const array = new Uint8Array(data).buffer;
        this.parse(array);
        const { token, label, sensitive, ...keyAlg } = algorithm;
        this.publicKey = await this.getData().publicKey.export(keyAlg, keyUsages, this.crypto);
        const id = await this.computeID();
        const template = this.crypto.templateBuilder.build({
            action: "import",
            type: "request",
            attributes: {
                id,
                label: algorithm.label || "X509 Request",
                token: !!(algorithm.token),
            },
        });
        template.value = Buffer.from(data);
        this.p11Object = this.crypto.session.create(template).toType();
    }
    async exportCert() {
        return this.value;
    }
    toJSON() {
        return {
            publicKey: this.publicKey.toJSON(),
            subjectName: this.subjectName,
            type: this.type,
            value: pvtsutils.Convert.ToBase64Url(this.value),
        };
    }
    async exportKey(algorithm, usages) {
        if (!this.publicKey) {
            const publicKeyID = this.id.replace(/\w+-\w+-/i, "");
            const keyIndexes = await this.crypto.keyStorage.keys();
            for (const keyIndex of keyIndexes) {
                const parts = keyIndex.split("-");
                if (parts[0] === "public" && parts[2] === publicKeyID) {
                    if (algorithm && usages) {
                        this.publicKey = await this.crypto.keyStorage.getItem(keyIndex, algorithm, true, usages);
                    }
                    else {
                        this.publicKey = await this.crypto.keyStorage.getItem(keyIndex);
                    }
                    break;
                }
            }
            if (!this.publicKey) {
                if (algorithm && usages) {
                    this.publicKey = await this.getData().publicKey.export(algorithm, usages, this.crypto);
                }
                else {
                    this.publicKey = await this.getData().publicKey.export(this.crypto);
                }
            }
        }
        return this.publicKey;
    }
    parse(data) {
        try {
            this.csr = new x509.Pkcs10CertificateRequest(data);
        }
        catch {
            throw new ParserError("Cannot parse PKCS10 certificate request");
        }
    }
    getData() {
        if (!this.csr) {
            this.parse(this.value);
        }
        return this.csr;
    }
}

class X509Certificate extends CryptoCertificate {
    constructor() {
        super(...arguments);
        this.type = "x509";
    }
    get serialNumber() {
        return this.getData().serialNumber;
    }
    get notBefore() {
        return this.getData().notBefore;
    }
    get notAfter() {
        return this.getData().notAfter;
    }
    get issuerName() {
        return this.getData().issuer;
    }
    get subjectName() {
        return this.getData().subject;
    }
    get value() {
        Pkcs11Object.assertStorage(this.p11Object);
        return new Uint8Array(this.p11Object.value).buffer;
    }
    async importCert(data, algorithm, keyUsages) {
        const array = new Uint8Array(data);
        this.parse(array.buffer);
        const { token, label, sensitive, ...keyAlg } = algorithm;
        this.publicKey = await this.getData().publicKey.export(keyAlg, keyUsages, this.crypto);
        const id = await this.computeID();
        const certLabel = this.getName();
        const template = this.crypto.templateBuilder.build({
            action: "import",
            type: "x509",
            attributes: {
                id,
                label: algorithm.label || certLabel,
                token: !!(algorithm.token),
            },
        });
        template.value = Buffer.from(data);
        const asn = asn1Schema.AsnConvert.parse(data, asnX509.Certificate);
        template.serial = Buffer.from(asn1Schema.AsnConvert.serialize(asn1Schema.AsnIntegerArrayBufferConverter.toASN(asn.tbsCertificate.serialNumber)));
        template.subject = Buffer.from(asn1Schema.AsnConvert.serialize(asn.tbsCertificate.subject));
        template.issuer = Buffer.from(asn1Schema.AsnConvert.serialize(asn.tbsCertificate.issuer));
        this.p11Object = this.crypto.session.create(template).toType();
    }
    async exportCert() {
        return this.value;
    }
    toJSON() {
        return {
            publicKey: this.publicKey.toJSON(),
            notBefore: this.notBefore,
            notAfter: this.notAfter,
            subjectName: this.subjectName,
            issuerName: this.issuerName,
            serialNumber: this.serialNumber,
            type: this.type,
            value: pvtsutils.Convert.ToBase64Url(this.value),
        };
    }
    async exportKey(algorithm, usages) {
        if (!this.publicKey) {
            const publicKeyID = this.id.replace(/\w+-\w+-/i, "");
            const keyIndexes = await this.crypto.keyStorage.keys();
            for (const keyIndex of keyIndexes) {
                const parts = keyIndex.split("-");
                if (parts[0] === "public" && parts[2] === publicKeyID) {
                    if (algorithm && usages) {
                        this.publicKey = await this.crypto.keyStorage.getItem(keyIndex, algorithm, usages);
                    }
                    else {
                        this.publicKey = await this.crypto.keyStorage.getItem(keyIndex);
                    }
                    break;
                }
            }
            if (!this.publicKey) {
                if (algorithm && usages) {
                    this.publicKey = await this.getData().publicKey.export(algorithm, usages, this.crypto);
                }
                else {
                    this.publicKey = await this.getData().publicKey.export(this.crypto);
                }
            }
        }
        return this.publicKey;
    }
    parse(data) {
        try {
            this.x509 = new x509.X509Certificate(data);
        }
        catch {
            throw new ParserError("Cannot parse X509 certificate");
        }
    }
    getData() {
        if (!this.x509) {
            this.parse(this.value);
        }
        return this.x509;
    }
    getName() {
        const name = new x509.Name(this.subjectName).toJSON();
        for (const item of name) {
            const commonName = item.CN;
            if (commonName && commonName.length > 0) {
                return commonName[0];
            }
        }
        return this.subjectName;
    }
}

const TEMPLATES = [
    { class: graphene.ObjectClass.CERTIFICATE, certType: graphene.CertificateType.X_509, token: true },
    { class: graphene.ObjectClass.DATA, token: true, label: "X509 Request" },
];
class CertificateStorage {
    constructor(crypto) {
        this.crypto = crypto;
    }
    async getValue(key) {
        const storageObject = this.getItemById(key);
        if (storageObject instanceof graphene.X509Certificate) {
            const x509Object = storageObject.toType();
            const x509 = new X509Certificate(this.crypto);
            x509.p11Object = x509Object;
            return x509.exportCert();
        }
        else if (storageObject instanceof graphene.Data) {
            const x509Object = storageObject.toType();
            const x509request = new X509CertificateRequest(this.crypto);
            x509request.p11Object = x509Object;
            return x509request.exportCert();
        }
        return null;
    }
    async indexOf(item) {
        var _a;
        if (item instanceof CryptoCertificate && ((_a = item.p11Object) === null || _a === undefined ? undefined : _a.token)) {
            return CryptoCertificate.getID(item.p11Object);
        }
        return null;
    }
    async keys() {
        const keys = [];
        TEMPLATES.forEach((template) => {
            this.crypto.session.find(template, (obj) => {
                const item = obj.toType();
                const id = CryptoCertificate.getID(item);
                keys.push(id);
            });
        });
        return keys;
    }
    async clear() {
        const objects = [];
        TEMPLATES.forEach((template) => {
            this.crypto.session.find(template, (obj) => {
                objects.push(obj);
            });
        });
        objects.forEach((obj) => {
            obj.destroy();
        });
    }
    async hasItem(item) {
        const sessionObject = this.getItemById(item.id);
        return !!sessionObject;
    }
    async getItem(index, algorithm, usages) {
        const storageObject = this.getItemById(index);
        if (storageObject instanceof graphene.X509Certificate) {
            const x509Object = storageObject.toType();
            const x509 = new X509Certificate(this.crypto);
            x509.p11Object = x509Object;
            if (algorithm && usages) {
                await x509.exportKey(algorithm, usages);
            }
            else {
                await x509.exportKey();
            }
            return x509;
        }
        else if (storageObject instanceof graphene.Data) {
            const x509Object = storageObject.toType();
            const x509request = new X509CertificateRequest(this.crypto);
            x509request.p11Object = x509Object;
            if (algorithm && usages) {
                await x509request.exportKey(algorithm, usages);
            }
            else {
                await x509request.exportKey();
            }
            return x509request;
        }
        else {
            return null;
        }
    }
    async removeItem(key) {
        const sessionObject = this.getItemById(key);
        if (sessionObject) {
            sessionObject.destroy();
        }
    }
    async setItem(data) {
        if (!(data instanceof CryptoCertificate)) {
            throw new Error("Incoming data is not PKCS#11 CryptoCertificate");
        }
        Pkcs11Object.assertStorage(data.p11Object);
        if (!data.p11Object.token) {
            const template = this.crypto.templateBuilder.build({
                action: "copy",
                type: data.type,
                attributes: {
                    token: true,
                }
            });
            const obj = this.crypto.session.copy(data.p11Object, template);
            return CryptoCertificate.getID(obj.toType());
        }
        else {
            return data.id;
        }
    }
    async exportCert(format, cert) {
        switch (format) {
            case "pem": {
                throw Error("PEM format is not implemented");
            }
            case "raw": {
                return cert.exportCert();
            }
            default:
                throw new Error(`Unsupported format in use ${format}`);
        }
    }
    async importCert(format, data, algorithm, usages) {
        let rawData;
        let rawType = null;
        switch (format) {
            case "pem":
                if (typeof data !== "string") {
                    throw new TypeError("data: Is not type string");
                }
                if (core.PemConverter.isCertificate(data)) {
                    rawType = "x509";
                }
                else if (core.PemConverter.isCertificateRequest(data)) {
                    rawType = "request";
                }
                else {
                    throw new core.OperationError("data: Is not correct PEM data. Must be Certificate or Certificate Request");
                }
                rawData = core.PemConverter.toArrayBuffer(data);
                break;
            case "raw":
                if (!pvtsutils.BufferSourceConverter.isBufferSource(data)) {
                    throw new TypeError("data: Is not type ArrayBuffer or ArrayBufferView");
                }
                rawData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
                break;
            default:
                throw new TypeError("format: Is invalid value. Must be 'raw', 'pem'");
        }
        switch (rawType) {
            case "x509": {
                const x509 = new X509Certificate(this.crypto);
                await x509.importCert(Buffer.from(rawData), algorithm, usages);
                return x509;
            }
            case "request": {
                const request = new X509CertificateRequest(this.crypto);
                await request.importCert(Buffer.from(rawData), algorithm, usages);
                return request;
            }
            default: {
                try {
                    const x509 = new X509Certificate(this.crypto);
                    await x509.importCert(Buffer.from(rawData), algorithm, usages);
                    return x509;
                }
                catch (e) {
                    if (!(e instanceof ParserError)) {
                        throw e;
                    }
                }
                try {
                    const request = new X509CertificateRequest(this.crypto);
                    await request.importCert(Buffer.from(rawData), algorithm, usages);
                    return request;
                }
                catch (e) {
                    if (!(e instanceof ParserError)) {
                        throw e;
                    }
                }
                throw new core.OperationError("Cannot parse Certificate or Certificate Request from incoming ASN1");
            }
        }
    }
    getItemById(id) {
        let object = null;
        TEMPLATES.forEach((template) => {
            this.crypto.session.find(template, (obj) => {
                const item = obj.toType();
                if (id === CryptoCertificate.getID(item)) {
                    object = item;
                    return false;
                }
            });
        });
        return object;
    }
}

const ID_DIGEST = "SHA-1";

function GUID() {
    return crypto.randomBytes(20);
}
function b64UrlDecode(b64url) {
    return Buffer.from(pvtsutils.Convert.FromBase64Url(b64url));
}
function prepareData(data) {
    return Buffer.from(pvtsutils.BufferSourceConverter.toArrayBuffer(data));
}
function isHashedAlgorithm(data) {
    return data instanceof Object
        && "name" in data
        && "hash" in data;
}
function isCryptoKeyPair(data) {
    return data instanceof Object
        && "privateKey" in data
        && "publicKey" in data;
}
function prepareAlgorithm(algorithm) {
    if (typeof algorithm === "string") {
        return {
            name: algorithm,
        };
    }
    if (isHashedAlgorithm(algorithm)) {
        const preparedAlgorithm = { ...algorithm };
        preparedAlgorithm.hash = prepareAlgorithm(algorithm.hash);
        return preparedAlgorithm;
    }
    return { ...algorithm };
}
function digest(algorithm, data) {
    const hash = crypto.createHash(algorithm.replace("-", ""));
    hash.update(prepareData(Buffer.from(pvtsutils.BufferSourceConverter.toArrayBuffer(data))));
    return hash.digest();
}
function calculateProviderID(slot) {
    const str = slot.manufacturerID + slot.slotDescription + slot.getToken().serialNumber + slot.handle.toString("hex");
    return digest(ID_DIGEST, Buffer.from(str)).toString("hex");
}
function getProviderInfo(slot) {
    const slots = slot.module.getSlots(true);
    let index = -1;
    for (let i = 0; i < slots.length; i++) {
        if (slots.items(i).handle.equals(slot.handle)) {
            index = i;
            break;
        }
    }
    const token = slot.getToken();
    const provider = {
        id: calculateProviderID(slot),
        slot: index,
        name: token.label,
        reader: slot.slotDescription,
        serialNumber: slot.getToken().serialNumber,
        algorithms: [],
        isRemovable: !!(slot.flags & graphene.SlotFlag.REMOVABLE_DEVICE),
        isHardware: !!(slot.flags & graphene.SlotFlag.HW_SLOT),
    };
    const algorithms = slot.getMechanisms();
    for (let i = 0; i < algorithms.length; i++) {
        const algorithm = algorithms.tryGetItem(i);
        if (!algorithm) {
            continue;
        }
        let algName = "";
        switch (algorithm.name) {
            case "SHA_1":
                algName = "SHA-1";
                break;
            case "SHA256":
                algName = "SHA-256";
                break;
            case "SHA384":
                algName = "SHA-384";
                break;
            case "SHA512":
                algName = "SHA-512";
                break;
            case "RSA_PKCS":
            case "SHA1_RSA_PKCS":
            case "SHA256_RSA_PKCS":
            case "SHA384_RSA_PKCS":
            case "SHA512_RSA_PKCS":
                algName = "RSASSA-PKCS1-v1_5";
                break;
            case "SHA1_RSA_PSS":
            case "SHA256_RSA_PSS":
            case "SHA384_RSA_PSS":
            case "SHA512_RSA_PSS":
                algName = "RSA-PSS";
                break;
            case "SHA1_RSA_PKCS_PSS":
            case "SHA256_RSA_PKCS_PSS":
            case "SHA384_RSA_PKCS_PSS":
            case "SHA512_RSA_PKCS_PSS":
                algName = "RSA-PSS";
                break;
            case "RSA_PKCS_OAEP":
                algName = "RSA-OAEP";
                break;
            case "ECDSA":
            case "ECDSA_SHA1":
            case "ECDSA_SHA256":
            case "ECDSA_SHA384":
            case "ECDSA_SHA512":
                algName = "ECDSA";
                break;
            case "ECDH1_DERIVE":
                algName = "ECDH";
                break;
            case "AES_CBC_PAD":
                algName = "AES-CBC";
                break;
            case "AES_ECB":
            case "AES_ECB_PAD":
                algName = "AES-ECB";
                break;
            case "AES_GCM_PAD":
                algName = "AES-GCM";
                break;
            case "AES_KEY_WRAP_PAD":
                algName = "AES-KW";
                break;
        }
        if (algName && !provider.algorithms.some((alg) => alg === algName)) {
            provider.algorithms.push(algName);
        }
    }
    return provider;
}
async function alwaysAuthenticate(key, container, operation) {
    if (key.key instanceof graphene.PrivateKey && key.key.alwaysAuthenticate) {
        if (!container.onAlwaysAuthenticate) {
            throw new core.CryptoError("Crypto key requires re-authentication, but Crypto doesn't have 'onAlwaysAuthenticate' method");
        }
        const pin = await container.onAlwaysAuthenticate(key, container, operation);
        if (pin) {
            container.session.login(pin, graphene.UserType.CONTEXT_SPECIFIC);
        }
    }
}

class AesCryptoKey extends CryptoKey {
    onAssign() {
        this.algorithm.length = this.key.get("valueLen") << 3;
    }
}

class AesCrypto {
    constructor(container) {
        this.container = container;
    }
    async generateKey(algorithm, extractable, keyUsages) {
        return new Promise((resolve, reject) => {
            const template = this.container.templateBuilder.build({
                action: "generate",
                type: "secret",
                attributes: {
                    id: GUID(),
                    label: algorithm.label || `AES-${algorithm.length}`,
                    token: algorithm.token,
                    sensitive: algorithm.sensitive,
                    extractable,
                    usages: keyUsages,
                },
            });
            template.keyType = graphene.KeyType.AES;
            template.valueLen = algorithm.length >> 3;
            this.container.session.generateKey(graphene.KeyGenMechanism.AES, template, (err, aesKey) => {
                try {
                    if (err) {
                        reject(new core.CryptoError(`Aes: Can not generate new key\n${err.message}`));
                    }
                    else {
                        if (!aesKey) {
                            throw new Error("Cannot get key from callback function");
                        }
                        resolve(new AesCryptoKey(aesKey, algorithm));
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    async exportKey(format, key) {
        const template = key.key.getAttribute({ value: null, valueLen: null });
        switch (format.toLowerCase()) {
            case "jwk": {
                const aes = /AES-(\w+)/.exec(key.algorithm.name)[1];
                const jwk = {
                    kty: "oct",
                    k: pvtsutils.Convert.ToBase64Url(template.value),
                    alg: `A${template.valueLen * 8}${aes}`,
                    ext: true,
                    key_ops: key.usages,
                };
                return jwk;
            }
            case "raw":
                return new Uint8Array(template.value).buffer;
            default:
                throw new core.OperationError("format: Must be 'jwk' or 'raw'");
        }
    }
    async importKey(format, keyData, algorithm, extractable, keyUsages) {
        const formatLower = format.toLowerCase();
        if (formatLower !== "jwk" && formatLower !== "raw") {
            throw new core.OperationError("format: Must be 'jwk' or 'raw'");
        }
        if (formatLower === "jwk") {
            const jwk = keyData;
            if (!jwk.k) {
                throw new core.OperationError("jwk.k: Cannot get required property");
            }
            keyData = pvtsutils.Convert.FromBase64Url(jwk.k);
        }
        const value = keyData;
        if (value.byteLength !== 16 && value.byteLength !== 24 && value.byteLength !== 32) {
            throw new core.OperationError("keyData: Is wrong key length");
        }
        const aesAlg = {
            ...AesCryptoKey.defaultKeyAlgorithm(),
            ...algorithm,
            length: value.byteLength * 8,
        };
        const template = this.container.templateBuilder.build({
            action: "import",
            type: "secret",
            attributes: {
                id: GUID(),
                label: algorithm.label || `AES-${aesAlg.length}`,
                token: algorithm.token,
                sensitive: algorithm.sensitive,
                extractable,
                usages: keyUsages,
            },
        });
        template.keyType = graphene.KeyType.AES;
        template.value = Buffer.from(value);
        const sessionObject = this.container.session.create(template);
        const key = new AesCryptoKey(sessionObject.toType(), aesAlg);
        return key;
    }
    async encrypt(padding, algorithm, key, data) {
        if (padding) {
            const blockLength = 16;
            const mod = blockLength - (data.byteLength % blockLength);
            const pad = Buffer.alloc(mod);
            pad.fill(mod);
            data = Buffer.concat([Buffer.from(data), pad]);
        }
        return new Promise((resolve, reject) => {
            const enc = Buffer.alloc(this.getOutputBufferSize(key.algorithm, true, data.byteLength));
            const mechanism = this.wc2pk11(algorithm);
            this.container.session.createCipher(mechanism, key.key)
                .once(Buffer.from(data), enc, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data2).buffer);
                }
            });
        });
    }
    async decrypt(padding, algorithm, key, data) {
        const dec = await new Promise((resolve, reject) => {
            const buf = Buffer.alloc(this.getOutputBufferSize(key.algorithm, false, data.length));
            const mechanism = this.wc2pk11(algorithm);
            this.container.session.createDecipher(mechanism, key.key)
                .once(Buffer.from(data), buf, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data2);
                }
            });
        });
        if (padding) {
            const paddingLength = dec[dec.length - 1];
            const res = new Uint8Array(dec.slice(0, dec.length - paddingLength));
            return res.buffer;
        }
        else {
            return new Uint8Array(dec).buffer;
        }
    }
    isAesGCM(algorithm) {
        return algorithm.name.toUpperCase() === "AES-GCM";
    }
    isAesCBC(algorithm) {
        return algorithm.name.toUpperCase() === "AES-CBC";
    }
    isAesECB(algorithm) {
        return algorithm.name.toUpperCase() === "AES-ECB";
    }
    wc2pk11(algorithm) {
        const session = this.container.session;
        if (this.isAesGCM(algorithm)) {
            const aad = algorithm.additionalData ? prepareData(algorithm.additionalData) : undefined;
            let AesGcmParamsClass = graphene.AesGcmParams;
            if (session.slot.module.cryptokiVersion.major >= 2 &&
                session.slot.module.cryptokiVersion.minor >= 40) {
                AesGcmParamsClass = graphene.AesGcm240Params;
            }
            const params = new AesGcmParamsClass(prepareData(algorithm.iv), aad, algorithm.tagLength || 128);
            return { name: "AES_GCM", params };
        }
        else if (this.isAesCBC(algorithm)) {
            return { name: "AES_CBC_PAD", params: prepareData(algorithm.iv) };
        }
        else if (this.isAesECB(algorithm)) {
            return { name: "AES_ECB", params: null };
        }
        else {
            throw new core.OperationError("Unrecognized algorithm name");
        }
    }
    getOutputBufferSize(keyAlg, enc, dataSize) {
        const len = keyAlg.length >> 3;
        if (enc) {
            return (Math.ceil(dataSize / len) * len) + len;
        }
        else {
            return dataSize;
        }
    }
}

class AesCbcProvider extends core.AesCbcProvider {
    constructor(container) {
        super();
        this.container = container;
        this.crypto = new AesCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    async onEncrypt(algorithm, key, data) {
        return this.crypto.encrypt(false, algorithm, key, new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return this.crypto.decrypt(false, algorithm, key, new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        Assert.isCryptoKey(key);
    }
}

class AesEcbProvider extends core.ProviderCrypto {
    constructor(container) {
        super();
        this.container = container;
        this.name = "AES-ECB";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
        this.crypto = new AesCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    async onEncrypt(algorithm, key, data) {
        return this.crypto.encrypt(true, algorithm, key, new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return this.crypto.decrypt(true, algorithm, key, new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof CryptoKey)) {
            throw new TypeError("key: Is not a PKCS11 CryptoKey");
        }
    }
}

class AesGcmProvider extends core.AesGcmProvider {
    constructor(container) {
        super();
        this.container = container;
        this.crypto = new AesCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    async onEncrypt(algorithm, key, data) {
        return this.crypto.encrypt(false, algorithm, key, new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return this.crypto.decrypt(false, algorithm, key, new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof CryptoKey)) {
            throw new TypeError("key: Is not a PKCS11 CryptoKey");
        }
    }
}

class EcCryptoKey extends CryptoKey {
    onAssign() {
        if (!this.algorithm.namedCurve) {
            try {
                const paramsECDSA = asn1Schema.AsnConvert.parse(this.key.get("paramsECDSA"), core.asn1.ObjectIdentifier);
                try {
                    const pointEC = core.EcCurves.get(paramsECDSA.value);
                    this.algorithm.namedCurve = pointEC.name;
                }
                catch {
                    this.algorithm.namedCurve = paramsECDSA.value;
                }
            }
            catch { }
        }
    }
}

const id_ecPublicKey = "1.2.840.10045.2.1";
class EcCrypto {
    constructor(container) {
        this.container = container;
        this.publicKeyUsages = ["verify"];
        this.privateKeyUsages = ["sign", "deriveKey", "deriveBits"];
    }
    async generateKey(algorithm, extractable, keyUsages) {
        return new Promise((resolve, reject) => {
            const attrs = {
                id: GUID(),
                label: algorithm.label,
                token: algorithm.token,
                sensitive: algorithm.sensitive,
                extractable,
                usages: keyUsages,
            };
            if (algorithm.alwaysAuthenticate) {
                attrs.alwaysAuthenticate = true;
            }
            const privateTemplate = this.createTemplate({
                action: "generate",
                type: "private",
                attributes: attrs,
            });
            const publicTemplate = this.createTemplate({
                action: "generate",
                type: "public",
                attributes: attrs,
            });
            publicTemplate.paramsEC = Buffer.from(core.EcCurves.get(algorithm.namedCurve).raw);
            this.container.session.generateKeyPair(graphene.KeyGenMechanism.EC, publicTemplate, privateTemplate, (err, keys) => {
                try {
                    if (err) {
                        reject(err);
                    }
                    else {
                        if (!keys) {
                            throw new Error("Cannot get keys from callback function");
                        }
                        const wcKeyPair = {
                            privateKey: new EcCryptoKey(keys.privateKey, algorithm),
                            publicKey: new EcCryptoKey(keys.publicKey, algorithm),
                        };
                        resolve(wcKeyPair);
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    async exportKey(format, key) {
        switch (format.toLowerCase()) {
            case "jwk": {
                if (key.type === "private") {
                    return this.exportJwkPrivateKey(key);
                }
                else {
                    return this.exportJwkPublicKey(key);
                }
            }
            case "pkcs8": {
                const jwk = await this.exportJwkPrivateKey(key);
                return this.jwk2pkcs(jwk);
            }
            case "spki": {
                const jwk = await this.exportJwkPublicKey(key);
                return this.jwk2spki(jwk);
            }
            case "raw": {
                const jwk = await this.exportJwkPublicKey(key);
                if (key.algorithm.namedCurve === "X25519") {
                    return pvtsutils.Convert.FromBase64Url(jwk.x);
                }
                else {
                    const publicKey = jsonSchema.JsonParser.fromJSON(jwk, { targetSchema: core.asn1.EcPublicKey });
                    return publicKey.value;
                }
            }
            default:
                throw new core.OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
        }
    }
    async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
            case "jwk": {
                const jwk = keyData;
                if (jwk.d) {
                    return this.importJwkPrivateKey(jwk, algorithm, extractable, keyUsages);
                }
                else {
                    return this.importJwkPublicKey(jwk, algorithm, extractable, keyUsages);
                }
            }
            case "spki": {
                const jwk = this.spki2jwk(keyData);
                return this.importJwkPublicKey(jwk, algorithm, extractable, keyUsages);
            }
            case "pkcs8": {
                const jwk = this.pkcs2jwk(keyData);
                return this.importJwkPrivateKey(jwk, algorithm, extractable, keyUsages);
            }
            case "raw": {
                const curve = core.EcCurves.get(algorithm.namedCurve);
                const ecPoint = core.EcUtils.decodePoint(keyData, curve.size);
                const jwk = {
                    kty: "EC",
                    crv: algorithm.namedCurve,
                    x: pvtsutils.Convert.ToBase64Url(ecPoint.x),
                };
                if (ecPoint.y) {
                    jwk.y = pvtsutils.Convert.ToBase64Url(ecPoint.y);
                }
                return this.importJwkPublicKey(jwk, algorithm, extractable, keyUsages);
            }
            default:
                throw new core.OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
        }
    }
    getAlgorithm(p11AlgorithmName) {
        const mechanisms = this.container.session.slot.getMechanisms();
        let EC;
        for (let i = 0; i < mechanisms.length; i++) {
            const mechanism = mechanisms.tryGetItem(i);
            if (mechanism && (mechanism.name === p11AlgorithmName || mechanism.name === "ECDSA")) {
                EC = mechanism.name;
            }
        }
        if (!EC) {
            throw new Error(`Cannot get PKCS11 EC mechanism by name '${p11AlgorithmName}'`);
        }
        return EC;
    }
    prepareData(hashAlgorithm, data) {
        return digest(hashAlgorithm.replace("-", ""), data);
    }
    importJwkPrivateKey(jwk, algorithm, extractable, keyUsages) {
        const template = this.createTemplate({
            action: "import",
            type: "private",
            attributes: {
                id: GUID(),
                token: algorithm.token,
                sensitive: algorithm.sensitive,
                label: algorithm.label,
                alwaysAuthenticate: algorithm.alwaysAuthenticate,
                extractable,
                usages: keyUsages,
            },
        });
        template.paramsEC = Buffer.from(core.EcCurves.get(algorithm.namedCurve).raw);
        template.value = b64UrlDecode(jwk.d);
        const p11key = this.container.session.create(template).toType();
        return new EcCryptoKey(p11key, algorithm);
    }
    importJwkPublicKey(jwk, algorithm, extractable, keyUsages) {
        const namedCurve = core.EcCurves.get(algorithm.namedCurve);
        const template = this.createTemplate({
            action: "import",
            type: "public",
            attributes: {
                id: GUID(),
                token: algorithm.token,
                label: algorithm.label,
                extractable,
                usages: keyUsages,
            }
        });
        template.paramsEC = Buffer.from(namedCurve.raw);
        let pointEc;
        if (namedCurve.name === "curve25519") {
            pointEc = b64UrlDecode(jwk.x);
        }
        else {
            const point = core.EcUtils.encodePoint({ x: b64UrlDecode(jwk.x), y: b64UrlDecode(jwk.y) }, namedCurve.size);
            const derPoint = asn1Schema.AsnConvert.serialize(new asn1Schema.OctetString(point));
            pointEc = Buffer.from(derPoint);
        }
        template.pointEC = pointEc;
        const p11key = this.container.session.create(template).toType();
        return new EcCryptoKey(p11key, algorithm);
    }
    exportJwkPublicKey(key) {
        const pkey = key.key.getAttribute({
            pointEC: null,
        });
        const curve = core.EcCurves.get(key.algorithm.namedCurve);
        const p11PointEC = pkey.pointEC;
        if (!p11PointEC) {
            throw new Error("Cannot get required ECPoint attribute");
        }
        const derEcPoint = asn1Schema.AsnConvert.parse(p11PointEC, asn1Schema.OctetString);
        const ecPoint = core.EcUtils.decodePoint(derEcPoint, curve.size);
        const jwk = {
            kty: "EC",
            crv: key.algorithm.namedCurve,
            ext: true,
            key_ops: key.usages,
            x: pvtsutils.Convert.ToBase64Url(ecPoint.x),
        };
        if (curve.name !== "curve25519") {
            jwk.y = pvtsutils.Convert.ToBase64Url(ecPoint.y);
        }
        return jwk;
    }
    async exportJwkPrivateKey(key) {
        const pkey = key.key.getAttribute({
            value: null,
        });
        const jwk = {
            kty: "EC",
            crv: key.algorithm.namedCurve,
            ext: true,
            key_ops: key.usages,
            d: pvtsutils.Convert.ToBase64Url(pkey.value),
        };
        return jwk;
    }
    createTemplate(params) {
        const template = this.container.templateBuilder.build({
            ...params,
            attributes: {
                ...params.attributes,
                label: params.attributes.label || "EC",
            },
        });
        template.keyType = graphene.KeyType.EC;
        return template;
    }
    spki2jwk(raw) {
        const keyInfo = asn1Schema.AsnParser.parse(raw, core.asn1.PublicKeyInfo);
        if (keyInfo.publicKeyAlgorithm.algorithm !== id_ecPublicKey) {
            throw new Error("SPKI is not EC public key");
        }
        const namedCurveId = asn1Schema.AsnParser.parse(keyInfo.publicKeyAlgorithm.parameters, core.asn1.ObjectIdentifier);
        const namedCurve = core.EcCurves.get(namedCurveId.value);
        const ecPublicKey = new core.asn1.EcPublicKey(keyInfo.publicKey);
        const json = jsonSchema.JsonSerializer.toJSON(ecPublicKey);
        return {
            kty: "EC",
            crv: namedCurve.name,
            ...json,
        };
    }
    jwk2pkcs(jwk) {
        Assert.requiredParameter(jwk.crv, "crv");
        const namedCurve = core.EcCurves.get(jwk.crv);
        const ecPrivateKey = jsonSchema.JsonParser.fromJSON(jwk, { targetSchema: core.asn1.EcPrivateKey });
        const keyInfo = new core.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm = new core.asn1.AlgorithmIdentifier();
        keyInfo.privateKeyAlgorithm.algorithm = id_ecPublicKey;
        keyInfo.privateKeyAlgorithm.parameters = namedCurve.raw;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(ecPrivateKey);
        return asn1Schema.AsnSerializer.serialize(keyInfo);
    }
    getCoordinate(b64, coordinateLength) {
        const buf = pvtsutils.Convert.FromBase64Url(b64);
        const offset = coordinateLength - buf.byteLength;
        const res = new Uint8Array(coordinateLength);
        res.set(new Uint8Array(buf), offset);
        return res.buffer;
    }
    jwk2spki(jwk) {
        if (!jwk.crv) {
            throw new Error("Absent mandatory parameter \"crv\"");
        }
        const namedCurve = core.EcCurves.get(jwk.crv);
        const ecPublicKey = jsonSchema.JsonParser.fromJSON(jwk, { targetSchema: core.asn1.EcPublicKey });
        const keyInfo = new core.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = id_ecPublicKey;
        keyInfo.publicKeyAlgorithm.parameters = namedCurve.raw;
        keyInfo.publicKey = ecPublicKey.value;
        return asn1Schema.AsnSerializer.serialize(keyInfo);
    }
    pkcs2jwk(raw) {
        const keyInfo = asn1Schema.AsnParser.parse(raw, core.asn1.PrivateKeyInfo);
        if (keyInfo.privateKeyAlgorithm.algorithm !== id_ecPublicKey) {
            throw new Error("PKCS8 is not EC private key");
        }
        if (!keyInfo.privateKeyAlgorithm.parameters) {
            throw new Error("Cannot get required Named curve parameters from ASN.1 PrivateKeyInfo structure");
        }
        const namedCurveId = asn1Schema.AsnParser.parse(keyInfo.privateKeyAlgorithm.parameters, core.asn1.ObjectIdentifier);
        const namedCurve = core.EcCurves.get(namedCurveId.value);
        const ecPrivateKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core.asn1.EcPrivateKey);
        const json = jsonSchema.JsonSerializer.toJSON(ecPrivateKey);
        return {
            kty: "EC",
            crv: namedCurve.name,
            ...json,
        };
    }
}

class EcdhProvider extends core.EcdhProvider {
    constructor(container) {
        super();
        this.container = container;
        this.namedCurves = core.EcCurves.names;
        this.usages = {
            privateKey: ["sign", "deriveKey", "deriveBits"],
            publicKey: ["verify"],
        };
        this.crypto = new EcCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof EcCryptoKey)) {
            throw new TypeError("key: Is not EC CryptoKey");
        }
    }
    async onDeriveBits(algorithm, baseKey, length) {
        return new Promise((resolve, reject) => {
            let valueLen = 256;
            switch (baseKey.algorithm.namedCurve) {
                case "P-256":
                case "K-256":
                    valueLen = 256;
                    break;
                case "P-384":
                    valueLen = 384;
                    break;
                case "P-521":
                    valueLen = 534;
                    break;
            }
            const template = {
                token: false,
                sensitive: false,
                class: graphene.ObjectClass.SECRET_KEY,
                keyType: graphene.KeyType.GENERIC_SECRET,
                extractable: true,
                encrypt: true,
                decrypt: true,
                valueLen: valueLen >> 3,
            };
            const ecPoint = algorithm.public.key.getAttribute({ pointEC: null }).pointEC;
            this.container.session.deriveKey({
                name: "ECDH1_DERIVE",
                params: new graphene.EcdhParams(graphene.EcKdf.NULL, null, ecPoint),
            }, baseKey.key, template, (err, key) => {
                if (err) {
                    reject(err);
                }
                else {
                    if (!key) {
                        throw new Error("Cannot get key from callback function");
                    }
                    const secretKey = key.toType();
                    const value = secretKey.getAttribute({ value: null }).value;
                    resolve(new Uint8Array(value.slice(0, length >> 3)).buffer);
                }
            });
        });
    }
}

class EcdsaProvider extends core.EcdsaProvider {
    constructor(container) {
        super();
        this.container = container;
        this.namedCurves = core.EcCurves.names;
        this.usages = {
            privateKey: ["sign", "deriveKey", "deriveBits"],
            publicKey: ["verify"],
        };
        this.crypto = new EcCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    async onSign(algorithm, key, data) {
        let buf = Buffer.from(data);
        const mechanism = this.wc2pk11(algorithm, algorithm);
        mechanism.name = this.crypto.getAlgorithm(mechanism.name);
        if (mechanism.name === "ECDSA") {
            buf = this.crypto.prepareData(algorithm.hash.name, buf);
        }
        const signer = this.container.session.createSign(mechanism, key.key);
        try {
            await alwaysAuthenticate(key, this.container, "sign");
        }
        catch (e) {
            try {
                signer.once(buf);
            }
            catch {
            }
            throw e;
        }
        return new Promise((resolve, reject) => {
            signer.once(buf, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data2).buffer);
                }
            });
        });
    }
    async onVerify(algorithm, key, signature, data) {
        return new Promise((resolve, reject) => {
            let buf = Buffer.from(data);
            const mechanism = this.wc2pk11(algorithm, algorithm);
            mechanism.name = this.crypto.getAlgorithm(mechanism.name);
            if (mechanism.name === "ECDSA") {
                buf = this.crypto.prepareData(algorithm.hash.name, buf);
            }
            this.container.session.createVerify(mechanism, key.key).once(buf, Buffer.from(signature), (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data2);
                }
            });
        });
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof EcCryptoKey)) {
            throw new TypeError("key: Is not EC CryptoKey");
        }
    }
    wc2pk11(alg, _keyAlg) {
        let algName;
        const hashAlg = alg.hash.name.toUpperCase();
        switch (hashAlg) {
            case "SHA-1":
                algName = "ECDSA_SHA1";
                break;
            case "SHA-224":
                algName = "ECDSA_SHA224";
                break;
            case "SHA-256":
                algName = "ECDSA_SHA256";
                break;
            case "SHA-384":
                algName = "ECDSA_SHA384";
                break;
            case "SHA-512":
                algName = "ECDSA_SHA512";
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${hashAlg}'`);
        }
        return { name: algName, params: null };
    }
}

class HmacCryptoKey extends CryptoKey {
    onAssign() {
        this.algorithm.length = this.key.get("valueLen") << 3;
    }
}

class HmacProvider extends core.HmacProvider {
    constructor(container) {
        super();
        this.container = container;
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        return new Promise((resolve, reject) => {
            const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;
            algorithm = { ...algorithm, name: this.name, length };
            const template = this.createTemplate({
                action: "generate",
                type: "secret",
                attributes: {
                    token: algorithm.token,
                    sensitive: algorithm.sensitive,
                    label: algorithm.label,
                    extractable,
                    usages: keyUsages
                },
            });
            template.valueLen = length >> 3;
            this.container.session.generateKey(graphene.KeyGenMechanism.GENERIC_SECRET, template, (err, key) => {
                try {
                    if (err) {
                        reject(new core.CryptoError(`HMAC: Cannot generate new key\n${err.message}`));
                    }
                    else {
                        if (!key) {
                            throw new Error("Cannot get key from callback function");
                        }
                        resolve(new HmacCryptoKey(key, algorithm));
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    async onSign(algorithm, key, data) {
        return new Promise((resolve, reject) => {
            const mechanism = this.wc2pk11(algorithm, key.algorithm);
            this.container.session.createSign(mechanism, key.key).once(Buffer.from(data), (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data2).buffer);
                }
            });
        });
    }
    async onVerify(algorithm, key, signature, data) {
        return new Promise((resolve, reject) => {
            const mechanism = this.wc2pk11(algorithm, key.algorithm);
            this.container.session.createVerify(mechanism, key.key).once(Buffer.from(data), Buffer.from(signature), (err, ok) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(ok);
                }
            });
        });
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        let value;
        switch (format.toLowerCase()) {
            case "jwk": {
                const jwk = keyData;
                if (!jwk.k) {
                    throw new core.OperationError("jwk.k: Cannot get required property");
                }
                keyData = pvtsutils.Convert.FromBase64Url(jwk.k);
                value = keyData;
                break;
            }
            case "raw": {
                value = keyData;
                break;
            }
            default:
                throw new core.OperationError("format: Must be 'jwk' or 'raw'");
        }
        const hmacAlg = {
            ...algorithm,
            name: this.name,
            length: value.byteLength * 8 || this.getDefaultLength(algorithm.hash.name),
        };
        const template = this.createTemplate({
            action: "import",
            type: "secret",
            attributes: {
                token: algorithm.token,
                sensitive: algorithm.sensitive,
                label: algorithm.label,
                extractable,
                usages: keyUsages
            },
        });
        template.value = Buffer.from(value);
        const sessionObject = this.container.session.create(template);
        const key = new HmacCryptoKey(sessionObject.toType(), hmacAlg);
        return key;
    }
    async onExportKey(format, key) {
        const template = key.key.getAttribute({ value: null });
        switch (format.toLowerCase()) {
            case "jwk": {
                const jwk = {
                    kty: "oct",
                    k: pvtsutils.Convert.ToBase64Url(template.value),
                    alg: `HS${key.algorithm.hash.name.replace("SHA-", "")}`,
                    ext: true,
                    key_ops: key.usages,
                };
                return jwk;
            }
            case "raw":
                return new Uint8Array(template.value).buffer;
            default:
                throw new core.OperationError("format: Must be 'jwk' or 'raw'");
        }
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof HmacCryptoKey)) {
            throw new TypeError("key: Is not HMAC CryptoKey");
        }
    }
    createTemplate(params) {
        const template = this.container.templateBuilder.build({
            ...params,
            attributes: {
                ...params.attributes,
                id: GUID(),
                label: params.attributes.label || "HMAC",
            },
        });
        template.keyType = graphene.KeyType.GENERIC_SECRET;
        return template;
    }
    wc2pk11(alg, keyAlg) {
        let res;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                res = "SHA_1_HMAC";
                break;
            case "SHA-224":
                res = "SHA224_HMAC";
                break;
            case "SHA-256":
                res = "SHA256_HMAC";
                break;
            case "SHA-384":
                res = "SHA384_HMAC";
                break;
            case "SHA-512":
                res = "SHA512_HMAC";
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${keyAlg.hash.name}'`);
        }
        return { name: res, params: null };
    }
}

class RsaCryptoKey extends CryptoKey {
    onAssign() {
        if (!this.algorithm.modulusLength) {
            this.algorithm.modulusLength = 0;
            try {
                this.algorithm.modulusLength = this.key.get("modulus").length << 3;
            }
            catch { }
        }
        if (!this.algorithm.publicExponent) {
            this.algorithm.publicExponent = new Uint8Array(0);
            try {
                let publicExponent = this.key.get("publicExponent");
                publicExponent = publicExponent.length > 3
                    ? publicExponent.slice(publicExponent.length - 3)
                    : publicExponent;
                this.algorithm.publicExponent = new Uint8Array(publicExponent);
            }
            catch { }
        }
    }
}

const HASH_PREFIXES = {
    "sha-1": Buffer.from([0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14]),
    "sha-256": Buffer.from([0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20]),
    "sha-384": Buffer.from([0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30]),
    "sha-512": Buffer.from([0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40]),
};
class RsaCrypto {
    constructor(container) {
        this.container = container;
        this.publicKeyUsages = ["verify", "encrypt", "wrapKey"];
        this.privateKeyUsages = ["sign", "decrypt", "unwrapKey"];
    }
    async generateKey(algorithm, extractable, keyUsages) {
        const size = algorithm.modulusLength;
        const exp = Buffer.from(algorithm.publicExponent);
        const attrs = {
            id: GUID(),
            label: algorithm.label,
            token: algorithm.token,
            sensitive: algorithm.sensitive,
            extractable,
            usages: keyUsages,
        };
        if (algorithm.alwaysAuthenticate) {
            attrs.alwaysAuthenticate = true;
        }
        const privateTemplate = this.createTemplate({
            action: "generate",
            type: "private",
            attributes: attrs,
        });
        const publicTemplate = this.createTemplate({
            action: "generate",
            type: "public",
            attributes: attrs,
        });
        publicTemplate.publicExponent = exp;
        publicTemplate.modulusBits = size;
        return new Promise((resolve, reject) => {
            this.container.session.generateKeyPair(graphene.KeyGenMechanism.RSA, publicTemplate, privateTemplate, (err, keys) => {
                try {
                    if (err) {
                        reject(new core.CryptoError(`Rsa: Can not generate new key\n${err.message}`));
                    }
                    else {
                        if (!keys) {
                            throw new Error("Cannot get keys from callback function");
                        }
                        const wcKeyPair = {
                            privateKey: new RsaCryptoKey(keys.privateKey, algorithm),
                            publicKey: new RsaCryptoKey(keys.publicKey, algorithm),
                        };
                        resolve(wcKeyPair);
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    async exportKey(format, key) {
        switch (format.toLowerCase()) {
            case "jwk":
                if (key.type === "private") {
                    return this.exportJwkPrivateKey(key);
                }
                else {
                    return this.exportJwkPublicKey(key);
                }
            case "pkcs8": {
                const jwk = await this.exportJwkPrivateKey(key);
                return this.jwk2pkcs(jwk);
            }
            case "spki": {
                const jwk = await this.exportJwkPublicKey(key);
                return this.jwk2spki(jwk);
            }
            case "raw": {
                const jwk = await this.exportJwkPublicKey(key);
                const spki = this.jwk2spki(jwk);
                const asn = asn1Schema.AsnConvert.parse(spki, core.asn1.PublicKeyInfo);
                return asn.publicKey;
            }
            default:
                throw new core.OperationError("format: Must be 'raw', 'jwk', 'pkcs8' or 'spki'");
        }
    }
    async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
            case "jwk": {
                const jwk = keyData;
                if (jwk.d) {
                    return this.importJwkPrivateKey(jwk, algorithm, extractable, keyUsages);
                }
                else {
                    return this.importJwkPublicKey(jwk, algorithm, extractable, keyUsages);
                }
            }
            case "spki": {
                const raw = new Uint8Array(keyData).buffer;
                const jwk = this.spki2jwk(raw);
                return this.importJwkPublicKey(jwk, algorithm, extractable, keyUsages);
            }
            case "pkcs8": {
                const raw = new Uint8Array(keyData).buffer;
                const jwk = this.pkcs2jwk(raw);
                return this.importJwkPrivateKey(jwk, algorithm, extractable, keyUsages);
            }
            default:
                throw new core.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
        }
    }
    getAlgorithm(wcAlgorithmName, p11AlgorithmName) {
        const DEFAULT_RSA = wcAlgorithmName === "RSASSA-PKCS1-v1_5" ? "RSA_PKCS"
            : wcAlgorithmName === "RSA-PSS" ? "RSA_PKCS_PSS"
                : wcAlgorithmName === "RSA-OAEP" ? "RSA_PKCS_OAEP" : "RSA_PKCS";
        const mechanisms = this.container.session.slot.getMechanisms();
        let RSA;
        for (let i = 0; i < mechanisms.length; i++) {
            const mechanism = mechanisms.tryGetItem(i);
            if (mechanism && (mechanism.name === p11AlgorithmName || mechanism.name === DEFAULT_RSA)) {
                RSA = mechanism.name;
            }
        }
        if (!RSA) {
            throw new Error(`Cannot get PKCS11 RSA mechanism by name '${p11AlgorithmName}'`);
        }
        return RSA;
    }
    prepareData(hashAlgorithm, data) {
        const hash = digest(hashAlgorithm.replace("-", ""), data);
        const hashPrefix = HASH_PREFIXES[hashAlgorithm.toLowerCase()];
        if (!hashPrefix) {
            throw new Error(`Cannot get prefix for hash '${hashAlgorithm}'`);
        }
        return Buffer.concat([hashPrefix, hash]);
    }
    jwkAlgName(algorithm) {
        switch (algorithm.name.toUpperCase()) {
            case "RSA-OAEP": {
                const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
                return `RSA-OAEP${mdSize !== "1" ? `-${mdSize}` : ""}`;
            }
            case "RSASSA-PKCS1-V1_5":
                return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
            case "RSA-PSS":
                return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
            case "RSAES-PKCS1-V1_5":
                return `RSA`;
            default:
                throw new core.OperationError("algorithm: Is not recognized");
        }
    }
    async exportJwkPublicKey(key) {
        const pkey = key.key.getAttribute({
            publicExponent: null,
            modulus: null,
        });
        pkey.publicExponent = pkey.publicExponent.length > 3
            ? pkey.publicExponent.slice(pkey.publicExponent.length - 3)
            : pkey.publicExponent;
        const alg = this.jwkAlgName(key.algorithm);
        const jwk = {
            kty: "RSA",
            alg,
            ext: true,
            key_ops: key.usages,
            e: pvtsutils.Convert.ToBase64Url(pkey.publicExponent),
            n: pvtsutils.Convert.ToBase64Url(pkey.modulus),
        };
        return jwk;
    }
    async exportJwkPrivateKey(key) {
        const pkey = key.key.getAttribute({
            publicExponent: null,
            modulus: null,
            privateExponent: null,
            prime1: null,
            prime2: null,
            exp1: null,
            exp2: null,
            coefficient: null,
        });
        pkey.publicExponent = pkey.publicExponent.length > 3
            ? pkey.publicExponent.slice(pkey.publicExponent.length - 3)
            : pkey.publicExponent;
        const alg = this.jwkAlgName(key.algorithm);
        const jwk = {
            kty: "RSA",
            alg,
            ext: true,
            key_ops: key.usages,
            e: pvtsutils.Convert.ToBase64Url(pkey.publicExponent),
            n: pvtsutils.Convert.ToBase64Url(pkey.modulus),
            d: pvtsutils.Convert.ToBase64Url(pkey.privateExponent),
            p: pvtsutils.Convert.ToBase64Url(pkey.prime1),
            q: pvtsutils.Convert.ToBase64Url(pkey.prime2),
            dp: pvtsutils.Convert.ToBase64Url(pkey.exp1),
            dq: pvtsutils.Convert.ToBase64Url(pkey.exp2),
            qi: pvtsutils.Convert.ToBase64Url(pkey.coefficient),
        };
        return jwk;
    }
    importJwkPrivateKey(jwk, algorithm, extractable, keyUsages) {
        const template = this.createTemplate({
            action: "import",
            type: "private",
            attributes: {
                id: GUID(),
                token: algorithm.token,
                sensitive: algorithm.sensitive,
                label: algorithm.label,
                extractable,
                alwaysAuthenticate: algorithm.alwaysAuthenticate,
                usages: keyUsages
            },
        });
        template.publicExponent = b64UrlDecode(jwk.e);
        template.modulus = b64UrlDecode(jwk.n);
        template.privateExponent = b64UrlDecode(jwk.d);
        template.prime1 = b64UrlDecode(jwk.p);
        template.prime2 = b64UrlDecode(jwk.q);
        template.exp1 = b64UrlDecode(jwk.dp);
        template.exp2 = b64UrlDecode(jwk.dq);
        template.coefficient = b64UrlDecode(jwk.qi);
        const p11key = this.container.session.create(template).toType();
        return new RsaCryptoKey(p11key, algorithm);
    }
    importJwkPublicKey(jwk, algorithm, extractable, keyUsages) {
        const template = this.createTemplate({
            action: "import",
            type: "public",
            attributes: {
                id: GUID(),
                token: algorithm.token,
                label: algorithm.label,
                extractable,
                usages: keyUsages
            },
        });
        template.publicExponent = b64UrlDecode(jwk.e);
        template.modulus = b64UrlDecode(jwk.n);
        const p11key = this.container.session.create(template).toType();
        return new RsaCryptoKey(p11key, algorithm);
    }
    createTemplate(params) {
        const template = this.container.templateBuilder.build({
            ...params,
            attributes: {
                ...params.attributes,
                label: params.attributes.label || "RSA",
            }
        });
        template.keyType = graphene.KeyType.RSA;
        return template;
    }
    jwk2spki(jwk) {
        const key = jsonSchema.JsonParser.fromJSON(jwk, { targetSchema: core.asn1.RsaPublicKey });
        const keyInfo = new core.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);
        return asn1Schema.AsnSerializer.serialize(keyInfo);
    }
    jwk2pkcs(jwk) {
        const key = jsonSchema.JsonParser.fromJSON(jwk, { targetSchema: core.asn1.RsaPrivateKey });
        const keyInfo = new core.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        return asn1Schema.AsnSerializer.serialize(keyInfo);
    }
    pkcs2jwk(raw) {
        const keyInfo = asn1Schema.AsnParser.parse(raw, core.asn1.PrivateKeyInfo);
        if (keyInfo.privateKeyAlgorithm.algorithm !== "1.2.840.113549.1.1.1") {
            throw new Error("PKCS8 is not RSA private key");
        }
        const key = asn1Schema.AsnParser.parse(keyInfo.privateKey, core.asn1.RsaPrivateKey);
        const json = jsonSchema.JsonSerializer.toJSON(key);
        return {
            kty: "RSA",
            ...json,
        };
    }
    spki2jwk(raw) {
        const keyInfo = asn1Schema.AsnParser.parse(raw, core.asn1.PublicKeyInfo);
        if (keyInfo.publicKeyAlgorithm.algorithm !== "1.2.840.113549.1.1.1") {
            throw new Error("PKCS8 is not RSA private key");
        }
        const key = asn1Schema.AsnParser.parse(keyInfo.publicKey, core.asn1.RsaPublicKey);
        const json = jsonSchema.JsonSerializer.toJSON(key);
        return {
            kty: "RSA",
            ...json,
        };
    }
}

class RsaPssProvider extends core.RsaPssProvider {
    constructor(container) {
        super();
        this.container = container;
        this.usages = {
            privateKey: ["sign", "decrypt", "unwrapKey"],
            publicKey: ["verify", "encrypt", "wrapKey"],
        };
        this.crypto = new RsaCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    async onSign(algorithm, key, data) {
        let buf = Buffer.from(data);
        const mechanism = this.wc2pk11(algorithm, key.algorithm);
        mechanism.name = this.crypto.getAlgorithm(this.name, mechanism.name);
        if (mechanism.name === "RSA_PKCS_PSS") {
            buf = this.crypto.prepareData(key.algorithm.hash.name, buf);
        }
        const signer = this.container.session.createSign(mechanism, key.key);
        try {
            await alwaysAuthenticate(key, this.container, "sign");
        }
        catch (e) {
            try {
                signer.once(buf);
            }
            catch {
            }
            throw e;
        }
        return new Promise((resolve, reject) => {
            signer.once(buf, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data2).buffer);
                }
            });
        });
    }
    async onVerify(algorithm, key, signature, data) {
        return new Promise((resolve, reject) => {
            let buf = Buffer.from(data);
            const mechanism = this.wc2pk11(algorithm, key.algorithm);
            mechanism.name = this.crypto.getAlgorithm(this.name, mechanism.name);
            if (mechanism.name === "RSA_PKCS_PSS") {
                buf = this.crypto.prepareData(key.algorithm.hash.name, buf);
            }
            this.container.session.createVerify(mechanism, key.key).once(buf, Buffer.from(signature), (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data2);
                }
            });
        });
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof RsaCryptoKey)) {
            throw new TypeError("key: Is not PKCS11 CryptoKey");
        }
    }
    wc2pk11(alg, keyAlg) {
        let mech;
        let param;
        const saltLen = alg.saltLength;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                mech = "SHA1_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA1, graphene.RsaMgf.MGF1_SHA1, saltLen);
                break;
            case "SHA-224":
                mech = "SHA224_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA224, graphene.RsaMgf.MGF1_SHA224, saltLen);
                break;
            case "SHA-256":
                mech = "SHA256_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA256, graphene.RsaMgf.MGF1_SHA256, saltLen);
                break;
            case "SHA-384":
                mech = "SHA384_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA384, graphene.RsaMgf.MGF1_SHA384, saltLen);
                break;
            case "SHA-512":
                mech = "SHA512_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene.MechanismEnum.SHA512, graphene.RsaMgf.MGF1_SHA512, saltLen);
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${keyAlg.hash.name}'`);
        }
        return { name: mech, params: param };
    }
}

class ShaCrypto {
    static size(algorithm) {
        switch (algorithm.name.toUpperCase()) {
            case "SHA-1":
                return 160;
            case "SHA-256":
            case "SHA3-256":
                return 256;
            case "SHA-384":
            case "SHA3-384":
                return 384;
            case "SHA-512":
            case "SHA3-512":
                return 512;
            default:
                throw new Error("Unrecognized name");
        }
    }
    constructor(container) {
        this.container = container;
    }
    async digest(algorithm, data) {
        const p11Mech = {
            name: algorithm.name.toUpperCase().replace("-", ""),
            params: null,
        };
        return new Promise((resolve, reject) => {
            this.container.session.createDigest(p11Mech).once(Buffer.from(data), (err, data) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data).buffer);
                }
            });
        });
    }
}

class RsaOaepProvider extends core.RsaOaepProvider {
    constructor(container) {
        super();
        this.container = container;
        this.usages = {
            privateKey: ["sign", "decrypt", "unwrapKey"],
            publicKey: ["verify", "encrypt", "wrapKey"],
        };
        this.crypto = new RsaCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    hasRsaPkcsMechanism() {
        const mechanisms = this.container.session.slot.getMechanisms();
        for (let i = 0; i < mechanisms.length; i++) {
            const mechanism = mechanisms.tryGetItem(i);
            if (mechanism && (mechanism.type === graphene.MechanismEnum.RSA_X_509)) {
                return true;
            }
        }
        return false;
    }
    async onEncrypt(algorithm, key, data) {
        if (this.hasRsaPkcsMechanism()) {
            return this.onEncryptRsaX509(algorithm, key, data);
        }
        return this.onEncryptRsaOAEP(algorithm, key, data);
    }
    async onEncryptRsaOAEP(algorithm, key, data) {
        return new Promise((resolve, reject) => {
            const buf = Buffer.from(data);
            const mechanism = this.wc2pk11(algorithm, key.algorithm);
            const context = Buffer.alloc((key.algorithm).modulusLength >> 3);
            this.container.session.createCipher(mechanism, key.key).once(buf, context, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data2).buffer);
                }
            });
        });
    }
    async onEncryptRsaX509(algorithm, key, data) {
        const dataView = new Uint8Array(data);
        const keySize = Math.ceil(key.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(key.algorithm.hash) >> 3;
        const dataLength = dataView.byteLength;
        const psLength = keySize - dataLength - 2 * hashSize - 2;
        if (dataLength > keySize - 2 * hashSize - 2) {
            throw new Error("Data too large");
        }
        const message = new Uint8Array(keySize);
        const seed = message.subarray(1, hashSize + 1);
        crypto.randomFillSync(seed);
        const dataBlock = message.subarray(hashSize + 1);
        const labelHash = crypto.createHash(key.algorithm.hash.name.replace("-", ""))
            .update(core.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))
            .digest();
        dataBlock.set(labelHash, 0);
        dataBlock[hashSize + psLength] = 1;
        dataBlock.set(dataView, hashSize + psLength + 1);
        const dataBlockMask = this.mgf1(key.algorithm.hash, seed, dataBlock.length);
        for (let i = 0; i < dataBlock.length; i++) {
            dataBlock[i] ^= dataBlockMask[i];
        }
        const seedMask = this.mgf1(key.algorithm.hash, dataBlock, seed.length);
        for (let i = 0; i < seed.length; i++) {
            seed[i] ^= seedMask[i];
        }
        return new Promise((resolve, reject) => {
            const buf = Buffer.from(message);
            const context = Buffer.alloc((key.algorithm).modulusLength >> 3);
            this.container.session.createCipher(graphene.MechanismEnum.RSA_X_509, key.key)
                .once(buf, context, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(core.BufferSourceConverter.toArrayBuffer(data2));
                }
            });
        });
    }
    async onDecrypt(algorithm, key, data) {
        if (this.hasRsaPkcsMechanism()) {
            return this.onDecryptRsaX509(algorithm, key, data);
        }
        return this.onDecryptRsaOAEP(algorithm, key, data);
    }
    async onDecryptRsaOAEP(algorithm, key, data) {
        const buf = Buffer.from(data);
        const mechanism = this.wc2pk11(algorithm, key.algorithm);
        const context = Buffer.alloc((key.algorithm).modulusLength >> 3);
        const decipher = this.container.session.createDecipher(mechanism, key.key);
        try {
            await alwaysAuthenticate(key, this.container, "decrypt");
        }
        catch (e) {
            try {
                decipher.once(buf, context);
            }
            catch {
            }
            throw e;
        }
        return new Promise((resolve, reject) => {
            decipher.once(buf, context, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data2).buffer);
                }
            });
        });
    }
    async onDecryptRsaX509(algorithm, key, data) {
        const keySize = Math.ceil(key.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(key.algorithm.hash) >> 3;
        if (data.byteLength > keySize || keySize < 2 * hashSize + 2) {
            throw new Error("Data too large");
        }
        const buf = Buffer.from(data);
        const context = Buffer.alloc((key.algorithm).modulusLength >> 3);
        const decipher = this.container.session.createDecipher(graphene.MechanismEnum.RSA_X_509, key.key);
        try {
            await alwaysAuthenticate(key, this.container, "decrypt");
        }
        catch (e) {
            try {
                decipher.once(buf, context);
            }
            catch {
            }
            throw e;
        }
        const pkcs0 = await new Promise((resolve, reject) => {
            decipher.once(buf, context, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data2);
                }
            });
        });
        const z = pkcs0[0];
        const seed = pkcs0.subarray(1, hashSize + 1);
        const dataBlock = pkcs0.subarray(hashSize + 1);
        if (z !== 0) {
            throw new Error("Decryption failed");
        }
        const seedMask = this.mgf1(key.algorithm.hash, dataBlock, seed.length);
        for (let i = 0; i < seed.length; i++) {
            seed[i] ^= seedMask[i];
        }
        const dataBlockMask = this.mgf1(key.algorithm.hash, seed, dataBlock.length);
        for (let i = 0; i < dataBlock.length; i++) {
            dataBlock[i] ^= dataBlockMask[i];
        }
        const labelHash = crypto.createHash(key.algorithm.hash.name.replace("-", ""))
            .update(core.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))
            .digest();
        const expectedLabelHash = dataBlock.subarray(0, hashSize);
        if (!core.BufferSourceConverter.isEqual(expectedLabelHash, labelHash)) {
            throw new Error("Label hash mismatch");
        }
        let index = hashSize + 1;
        while (dataBlock[index] === 0) {
            index++;
        }
        if (dataBlock[index++] !== 1) {
            throw new Error("Invalid padding");
        }
        return core.BufferSourceConverter.toArrayBuffer(dataBlock.subarray(index));
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof RsaCryptoKey)) {
            throw new TypeError("key: Is not PKCS11 CryptoKey");
        }
    }
    wc2pk11(alg, keyAlg) {
        let params;
        const sourceData = alg.label ? Buffer.from(alg.label) : undefined;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA1, graphene.RsaMgf.MGF1_SHA1, sourceData);
                break;
            case "SHA-224":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA224, graphene.RsaMgf.MGF1_SHA224, sourceData);
                break;
            case "SHA-256":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA256, graphene.RsaMgf.MGF1_SHA256, sourceData);
                break;
            case "SHA-384":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA384, graphene.RsaMgf.MGF1_SHA384, sourceData);
                break;
            case "SHA-512":
                params = new graphene.RsaOaepParams(graphene.MechanismEnum.SHA512, graphene.RsaMgf.MGF1_SHA512, sourceData);
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${keyAlg.hash.name}'`);
        }
        const res = { name: "RSA_PKCS_OAEP", params };
        return res;
    }
    mgf1(algorithm, seed, length = 0) {
        const hashSize = ShaCrypto.size(algorithm) >> 3;
        const mask = new Uint8Array(length);
        const counter = new Uint8Array(4);
        const chunks = Math.ceil(length / hashSize);
        for (let i = 0; i < chunks; i++) {
            counter[0] = i >>> 24;
            counter[1] = (i >>> 16) & 255;
            counter[2] = (i >>> 8) & 255;
            counter[3] = i & 255;
            const subMask = mask.subarray(i * hashSize);
            let chunk = crypto.createHash(algorithm.name.replace("-", ""))
                .update(seed)
                .update(counter)
                .digest();
            if (chunk.length > subMask.length) {
                chunk = chunk.subarray(0, subMask.length);
            }
            subMask.set(chunk);
        }
        return mask;
    }
}

class RsaSsaProvider extends core.RsaSsaProvider {
    constructor(container) {
        super();
        this.container = container;
        this.usages = {
            privateKey: ["sign", "decrypt", "unwrapKey"],
            publicKey: ["verify", "encrypt", "wrapKey"],
        };
        this.crypto = new RsaCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await this.crypto.generateKey({ ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    async onSign(algorithm, key, data) {
        let buf = Buffer.from(data);
        const mechanism = this.wc2pk11(algorithm, key.algorithm);
        mechanism.name = this.crypto.getAlgorithm(this.name, mechanism.name);
        if (mechanism.name === "RSA_PKCS") {
            buf = this.crypto.prepareData(key.algorithm.hash.name, buf);
        }
        const signer = this.container.session.createSign(mechanism, key.key);
        try {
            await alwaysAuthenticate(key, this.container, "sign");
        }
        catch (e) {
            try {
                signer.once(buf);
            }
            catch {
            }
            throw e;
        }
        return new Promise((resolve, reject) => {
            signer.once(buf, (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Uint8Array(data2).buffer);
                }
            });
        });
    }
    async onVerify(algorithm, key, signature, data) {
        return new Promise((resolve, reject) => {
            let buf = Buffer.from(data);
            const mechanism = this.wc2pk11(algorithm, key.algorithm);
            mechanism.name = this.crypto.getAlgorithm(this.name, mechanism.name);
            if (mechanism.name === "RSA_PKCS") {
                buf = this.crypto.prepareData(key.algorithm.hash.name, buf);
            }
            this.container.session.createVerify(mechanism, key.key).once(buf, Buffer.from(signature), (err, data2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data2);
                }
            });
        });
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await this.crypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return key;
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(key instanceof RsaCryptoKey)) {
            throw new TypeError("key: Is not PKCS11 CryptoKey");
        }
    }
    wc2pk11(alg, keyAlg) {
        let res;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                res = "SHA1_RSA_PKCS";
                break;
            case "SHA-224":
                res = "SHA224_RSA_PKCS";
                break;
            case "SHA-256":
                res = "SHA256_RSA_PKCS";
                break;
            case "SHA-384":
                res = "SHA384_RSA_PKCS";
                break;
            case "SHA-512":
                res = "SHA512_RSA_PKCS";
                break;
            default:
                throw new core.OperationError(`Cannot create PKCS11 mechanism from algorithm '${keyAlg.hash.name}'`);
        }
        return { name: res, params: null };
    }
}

class RsaEsProvider extends core.RsaProvider {
    constructor(container) {
        super();
        this.container = container;
        this.name = "RSAES-PKCS1-v1_5";
        this.usages = {
            privateKey: ["decrypt", "unwrapKey"],
            publicKey: ["encrypt", "wrapKey"],
        };
        this.crypto = new RsaCrypto(container);
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        return this.crypto.generateKey(algorithm, extractable, keyUsages);
    }
    async onExportKey(format, key) {
        return this.crypto.exportKey(format, key);
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        return this.crypto.importKey(format, keyData, algorithm, extractable, keyUsages);
    }
    async onEncrypt(algorithm, key, data) {
        return this.cryptOperation('encrypt', key, data);
    }
    async onDecrypt(algorithm, key, data) {
        return this.cryptOperation('decrypt', key, data);
    }
    async cryptOperation(type, key, data) {
        const mechanism = { name: "RSA_PKCS", params: null };
        const buf = Buffer.from(data);
        const context = Buffer.alloc((key.algorithm).modulusLength >> 3);
        return new Promise((resolve, reject) => {
            const operation = type === 'encrypt'
                ? this.container.session.createCipher(mechanism, key.key)
                : this.container.session.createDecipher(mechanism, key.key);
            let rejected = false;
            alwaysAuthenticate(key, this.container, "sign")
                .catch((e) => {
                try {
                    operation.once(buf, context);
                }
                catch {
                }
                reject(e);
                rejected = true;
            })
                .then(() => {
                if (rejected) {
                    return;
                }
                operation.once(buf, context, (err, data) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        });
    }
    checkGenerateKeyParams(algorithm) {
        return super.checkGenerateKeyParams({
            ...algorithm,
            hash: { name: "SHA-256" },
        });
    }
    checkImportParams(algorithm) {
        return super.checkImportParams({
            ...algorithm,
            hash: { name: "SHA-256" },
        });
    }
}

class Sha1Provider extends core.ProviderCrypto {
    constructor(container) {
        super();
        this.container = container;
        this.name = "SHA-1";
        this.usages = [];
        this.crypto = new ShaCrypto(container);
    }
    async onDigest(algorithm, data) {
        return this.crypto.digest(algorithm, data);
    }
}

class Sha256Provider extends Sha1Provider {
    constructor() {
        super(...arguments);
        this.name = "SHA-256";
    }
}

class Sha384Provider extends Sha1Provider {
    constructor() {
        super(...arguments);
        this.name = "SHA-384";
    }
}

class Sha512Provider extends Sha1Provider {
    constructor() {
        super(...arguments);
        this.name = "SHA-512";
    }
}

class ShakeCrypto {
    static digest(algorithm, data) {
        const hash = crypto.createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length })
            .update(Buffer.from(data)).digest();
        return pvtsutils.BufferSourceConverter.toArrayBuffer(hash);
    }
}

class Shake128Provider extends core.Shake128Provider {
    async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
    }
}

class Shake256Provider extends core.Shake256Provider {
    async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
    }
}

const OBJECT_TYPES = [graphene.ObjectClass.PRIVATE_KEY, graphene.ObjectClass.PUBLIC_KEY, graphene.ObjectClass.SECRET_KEY];
class KeyStorage {
    constructor(crypto) {
        this.crypto = crypto;
    }
    async keys() {
        const keys = [];
        OBJECT_TYPES.forEach((objectClass) => {
            this.crypto.session.find({ class: objectClass, token: true }, (obj) => {
                const item = obj.toType();
                keys.push(CryptoKey.getID(item));
            });
        });
        return keys;
    }
    async indexOf(item) {
        if (item instanceof CryptoKey && item.key.token) {
            return CryptoKey.getID(item.key);
        }
        return null;
    }
    async clear() {
        const keys = [];
        OBJECT_TYPES.forEach((objectClass) => {
            this.crypto.session.find({ class: objectClass, token: true }, (obj) => {
                keys.push(obj);
            });
        });
        keys.forEach((key) => {
            key.destroy();
        });
    }
    async getItem(key, ...args) {
        const subjectObject = this.getItemById(key);
        if (subjectObject) {
            const p11Key = subjectObject.toType();
            let alg;
            let algorithm;
            let usages;
            if (typeof args[0] === "object" && typeof args[1] === "boolean" && Array.isArray(args[2])) {
                algorithm = args[0];
                usages = args[2];
            }
            else if (typeof args[0] === "object" && Array.isArray(args[1])) {
                algorithm = args[0];
                usages = args[1];
            }
            if (algorithm) {
                alg = {
                    ...prepareAlgorithm(algorithm),
                    token: false,
                    sensitive: false,
                    label: "",
                };
            }
            else {
                alg = {
                    name: "",
                    token: false,
                    sensitive: false,
                    label: "",
                };
                switch (p11Key.type) {
                    case graphene.KeyType.RSA: {
                        if (p11Key.sign || p11Key.verify) {
                            alg.name = "RSASSA-PKCS1-v1_5";
                        }
                        else {
                            alg.name = "RSA-OAEP";
                        }
                        alg.hash = { name: "SHA-256" };
                        break;
                    }
                    case graphene.KeyType.EC: {
                        if (p11Key.sign || p11Key.verify) {
                            alg.name = "ECDSA";
                        }
                        else {
                            alg.name = "ECDH";
                        }
                        break;
                    }
                    case graphene.KeyType.GENERIC_SECRET:
                    case graphene.KeyType.AES: {
                        if (p11Key.sign || p11Key.verify) {
                            alg.name = "HMAC";
                        }
                        else {
                            alg.name = "AES-CBC";
                        }
                        break;
                    }
                    default:
                        throw new Error(`Unsupported type of key '${graphene.KeyType[p11Key.type] || p11Key.type}'`);
                }
            }
            let CryptoKeyClass;
            switch (alg.name.toUpperCase()) {
                case "RSASSA-PKCS1-V1_5":
                case "RSAES-PKCS1-V1_5":
                case "RSA-PSS":
                case "RSA-OAEP":
                    CryptoKeyClass = RsaCryptoKey;
                    break;
                case "ECDSA":
                case "ECDH":
                    CryptoKeyClass = EcCryptoKey;
                    break;
                case "HMAC":
                    CryptoKeyClass = HmacCryptoKey;
                    break;
                case "AES-CBC":
                case "AES-ECB":
                case "AES-GCM":
                    CryptoKeyClass = AesCryptoKey;
                    break;
                default:
                    CryptoKeyClass = CryptoKey;
            }
            const key = new CryptoKeyClass(p11Key, alg, usages);
            if (typeof args[1] === "boolean") {
                key.extractable = args[1];
            }
            return key;
        }
        else {
            throw new Error(`Certificate storage item not found`);
        }
    }
    async removeItem(key) {
        const sessionObject = this.getItemById(key);
        if (sessionObject) {
            sessionObject.destroy();
        }
    }
    async setItem(data) {
        if (!(data instanceof CryptoKey)) {
            throw new core.CryptoError("Parameter 1 is not P11CryptoKey");
        }
        const p11Key = data;
        const hasItem = await this.hasItem(data);
        if (!(hasItem && p11Key.key.token)) {
            const template = this.crypto.templateBuilder.build({
                action: "copy",
                type: p11Key.type,
                attributes: {
                    token: true,
                }
            });
            const obj = this.crypto.session.copy(p11Key.key, template);
            return CryptoKey.getID(obj.toType());
        }
        else {
            return data.id;
        }
    }
    async hasItem(key) {
        const item = this.getItemById(key.id);
        return !!item;
    }
    getItemById(id) {
        let key = null;
        OBJECT_TYPES.forEach((objectClass) => {
            this.crypto.session.find({ class: objectClass, token: true }, (obj) => {
                const item = obj.toType();
                if (id === CryptoKey.getID(item)) {
                    key = item;
                    return false;
                }
            });
        });
        return key;
    }
}

class SubtleCrypto extends core.SubtleCrypto {
    constructor(container) {
        super();
        this.container = container;
        this.providers.set(new AesCbcProvider(this.container));
        this.providers.set(new AesEcbProvider(this.container));
        this.providers.set(new AesGcmProvider(this.container));
        this.providers.set(new RsaSsaProvider(this.container));
        this.providers.set(new RsaPssProvider(this.container));
        this.providers.set(new RsaOaepProvider(this.container));
        this.providers.set(new RsaEsProvider(this.container));
        this.providers.set(new EcdsaProvider(this.container));
        this.providers.set(new EcdhProvider(this.container));
        this.providers.set(new Sha1Provider(this.container));
        this.providers.set(new Sha256Provider(this.container));
        this.providers.set(new Sha384Provider(this.container));
        this.providers.set(new Sha512Provider(this.container));
        this.providers.set(new HmacProvider(this.container));
        this.providers.set(new Shake128Provider());
        this.providers.set(new Shake256Provider());
    }
    async generateKey(algorithm, extractable, keyUsages) {
        const keys = await super.generateKey(algorithm, extractable, keyUsages);
        if (isCryptoKeyPair(keys)) {
            const publicKey = keys.publicKey;
            const privateKey = keys.privateKey;
            const digest = await this.computeId(publicKey);
            publicKey.key.id = digest;
            publicKey.id = CryptoKey.getID(publicKey.key);
            privateKey.key.id = digest;
            privateKey.id = CryptoKey.getID(privateKey.key);
        }
        return keys;
    }
    async computeId(publicKey) {
        const raw = await this.exportKey("spki", publicKey);
        const digest$1 = digest(ID_DIGEST, raw).slice(0, 16);
        return digest$1;
    }
    async importKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await super.importKey(format, keyData, algorithm, extractable, keyUsages);
        if (key.type === "public" && extractable) {
            const publicKey = key;
            const digest = await this.computeId(publicKey);
            publicKey.key.id = digest;
            publicKey.id = CryptoKey.getID(publicKey.key);
        }
        return key;
    }
}

class TemplateBuilder {
    build(params) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { attributes, action, type } = params;
        const template = {
            token: !!attributes.token,
        };
        if (action === "copy") {
            if (type === "private") {
                if (attributes.token) ;
            }
        }
        else {
            if (attributes.label) {
                template.label = attributes.label;
            }
            if (attributes.id) {
                template.id = Buffer.from(pvtsutils.BufferSourceConverter.toArrayBuffer(attributes.id));
            }
            const sign = (_a = attributes.usages) === null || _a === undefined ? undefined : _a.includes("sign");
            const verify = (_b = attributes.usages) === null || _b === undefined ? undefined : _b.includes("verify");
            const wrap = (_c = attributes.usages) === null || _c === undefined ? undefined : _c.includes("wrapKey");
            const unwrap = (_d = attributes.usages) === null || _d === undefined ? undefined : _d.includes("unwrapKey");
            const encrypt = unwrap || ((_e = attributes.usages) === null || _e === undefined ? undefined : _e.includes("encrypt"));
            const decrypt = wrap || ((_f = attributes.usages) === null || _f === undefined ? undefined : _f.includes("decrypt"));
            const derive = ((_g = attributes.usages) === null || _g === undefined ? undefined : _g.includes("deriveBits")) || ((_h = attributes.usages) === null || _h === undefined ? undefined : _h.includes("deriveKey"));
            switch (type) {
                case "private":
                    Object.assign(template, {
                        class: graphene.ObjectClass.PRIVATE_KEY,
                        sensitive: !!attributes.sensitive,
                        private: true,
                        extractable: !!attributes.extractable,
                        derive,
                        sign,
                        decrypt,
                        unwrap,
                    });
                    if (attributes.alwaysAuthenticate) {
                        template.alwaysAuth = true;
                    }
                    break;
                case "public":
                    Object.assign(template, {
                        token: !!attributes.token,
                        class: graphene.ObjectClass.PUBLIC_KEY,
                        private: false,
                        derive,
                        verify,
                        encrypt,
                        wrap,
                    });
                    break;
                case "secret":
                    Object.assign(template, {
                        class: graphene.ObjectClass.SECRET_KEY,
                        sensitive: !!attributes.sensitive,
                        extractable: !!attributes.extractable,
                        derive,
                        sign,
                        verify,
                        decrypt,
                        encrypt,
                        unwrap,
                        wrap,
                    });
                    break;
                case "request":
                    if (template.id) {
                        template.objectId = template.id;
                        delete template.id;
                    }
                    Object.assign(template, {
                        class: graphene.ObjectClass.DATA,
                        application: "webcrypto-p11",
                        private: false,
                    });
                    break;
                case "x509":
                    Object.assign(template, {
                        class: graphene.ObjectClass.CERTIFICATE,
                        certType: graphene.CertificateType.X_509,
                        private: false,
                    });
                    break;
            }
        }
        return template;
    }
}

var _Crypto_session;
const WebCryptoError = core.CryptoError;
class Crypto extends core.Crypto {
    get session() {
        Assert.isSession(__classPrivateFieldGet(this, _Crypto_session, "f"));
        return __classPrivateFieldGet(this, _Crypto_session, "f");
    }
    constructor(props) {
        super();
        _Crypto_session.set(this, undefined);
        this.templateBuilder = new TemplateBuilder();
        const mod = graphene.Module.load(props.library, props.name || props.library);
        this.name = props.name;
        try {
            if (props.libraryParameters) {
                mod.initialize({
                    libraryParameters: props.libraryParameters,
                });
            }
            else {
                mod.initialize();
            }
        }
        catch (e) {
            if (!(e instanceof pkcs11.Pkcs11Error && e.code === pkcs11.CKR_CRYPTOKI_ALREADY_INITIALIZED)) {
                throw e;
            }
        }
        this.initialized = true;
        const slotIndex = props.slot || 0;
        const slots = mod.getSlots(true);
        if (!(0 <= slotIndex && slotIndex < slots.length)) {
            throw new WebCryptoError(`Slot by index ${props.slot} is not found`);
        }
        this.slot = slots.items(slotIndex);
        this.token = this.slot.getToken();
        this.isLoginRequired = !!(this.token.flags & graphene.TokenFlag.LOGIN_REQUIRED);
        this.isLoggedIn = !this.isLoginRequired;
        this.isReadWrite = !!props.readWrite;
        this.open(props.readWrite);
        if (props.pin && this.isLoginRequired) {
            this.login(props.pin);
        }
        for (const i in props.vendors) {
            graphene.Mechanism.vendor(props.vendors[i]);
        }
        this.subtle = new SubtleCrypto(this);
        this.keyStorage = new KeyStorage(this);
        this.certStorage = new CertificateStorage(this);
    }
    open(rw) {
        let flags = graphene.SessionFlag.SERIAL_SESSION;
        if (rw) {
            flags |= graphene.SessionFlag.RW_SESSION;
        }
        __classPrivateFieldSet(this, _Crypto_session, this.slot.open(flags), "f");
        this.info = getProviderInfo(this.slot);
        if (this.info && this.name) {
            this.info.name = this.name;
        }
    }
    reset() {
        if (this.isLoggedIn && this.isLoginRequired) {
            this.logout();
        }
        this.session.close();
        this.open(this.isReadWrite);
    }
    login(pin) {
        if (!this.isLoginRequired) {
            return;
        }
        try {
            this.session.login(pin);
        }
        catch (error) {
            if (!(error instanceof pkcs11.Pkcs11Error && error.code === pkcs11.CKR_USER_ALREADY_LOGGED_IN)) {
                throw error;
            }
        }
        this.isLoggedIn = true;
    }
    logout() {
        if (!this.isLoginRequired) {
            return;
        }
        try {
            this.session.logout();
        }
        catch (error) {
            if (!(error instanceof pkcs11.Pkcs11Error && error.code === pkcs11.CKR_USER_NOT_LOGGED_IN)) {
                throw error;
            }
        }
        this.isLoggedIn = false;
    }
    getRandomValues(array) {
        if (!ArrayBuffer.isView(array)) {
            throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");
        }
        if (array.byteLength > 65536) {
            throw new core.CryptoError(`Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length (${array.byteLength}) exceeds the number of bytes of entropy available via this API (65536).`);
        }
        const bytes = new Uint8Array(this.session.generateRandom(array.byteLength));
        array.set(bytes);
        return array;
    }
    close() {
        if (this.initialized) {
            this.session.logout();
            this.session.close();
            this.slot.module.finalize();
            this.slot.module.close();
        }
    }
}
_Crypto_session = new WeakMap();

export { CertificateStorage, Crypto, CryptoCertificate, CryptoKey, KeyStorage, ParserError, SubtleCrypto, TemplateBuilder, X509Certificate, X509CertificateRequest };
